package com.taobao.f2e;

import org.apache.commons.cli.*;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.regex.Pattern;

/**
 * invoke module compiler for kissy
 *
 * @author yiminghe@gmail.com
 * @since 2011-01-18
 */
public class Main {

	static String DEP_PREFIX = "/*Generated By KISSY Module Compiler*/\n" +
			"if(KISSY.Loader){\n" +
			"KISSY.config('modules',{\n";

	static String DEP_SUFFIX = "\n});\n}";

	/**
	 * packages.
	 */
	private Packages packages = new Packages();

	/**
	 * exclude pattern for modules.
	 */
	private Pattern excludePattern;

	/**
	 * stack of visited modules to detect circular dependency
	 */
	private ArrayList<String> modulesVisited = new ArrayList<String>();

	/**
	 * requires mods name for current application.
	 */
	private String require = null;

	/**
	 * combined mods 's code 's output file path.
	 */
	private String output = "";//"d:/code/kissy_git/kissy-tools/module-compiler/test/kissy/combine.js";

	/**
	 * combined mods 's code 's output file encoding.
	 */
	private String outputEncoding = "utf-8";

	/**
	 * all processed modules.
	 */
	protected ArrayList<Module> modules = new ArrayList<Module>();

	/**
	 * whether overwrite module's file with module name added.
	 */
	private boolean fixModuleName = false;

	/**
	 * whether output dependency file path.
	 */
	private String outputDependency = null;

	/**
	 * dependencies
	 */
	private ArrayList<String> dependencies = new ArrayList<String>();

	public void setExcludePattern(Pattern excludePattern) {
		this.excludePattern = excludePattern;
	}

	public void setOutputDependency(String outputDependency) {
		this.outputDependency = outputDependency;
	}

	public void setFixModuleName(boolean fixModuleName) {
		this.fixModuleName = fixModuleName;
	}

	public void setOutput(String output) {
		this.output = output;
	}

	public Packages getPackages() {
		return packages;
	}

	public void setOutputEncoding(String outputEncoding) {
		this.outputEncoding = outputEncoding;
	}

	public void setRequire(String require) {
		this.require = require;
	}

	public void run() {
		long start = System.currentTimeMillis();

		combineRequire(require);

		ArrayList<String> combinedFiles = new ArrayList<String>();
		StringBuilder finalCodes = new StringBuilder();

		for (Module m : modules) {
			combinedFiles.add(m.getName());
			finalCodes.append(m.getCode());
		}

		String re = "/*\n Combined modules by KISSY Module Compiler: \n\n " +
				ArrayUtils.join(combinedFiles.toArray(new String[combinedFiles.size()]), "\n ")
				+ "\n*/\n\n" + finalCodes.toString();

		if (output != null) {
			FileUtils.outputContent(re, output, outputEncoding);
			System.out.println("success generated: " + output);
		} else {
			System.out.println(re);
		}

		if (outputDependency != null && dependencies.size() != 0) {
			re = DEP_PREFIX + "'" + require + "': {requires: '" +
					ArrayUtils.join(dependencies.toArray(new String[dependencies.size()]), "','")
					+ "'}" + DEP_SUFFIX;
			FileUtils.outputContent(re, outputDependency, outputEncoding);
			System.out.println("success generated: " + outputDependency);
		}

		System.out.print("duration: " + (System.currentTimeMillis() - start));
	}

	/**
	 * x -> a,b,c : x depends on a,b,c
	 * add a,b,c then add x to final code buffer
	 *
	 * @param requiredModuleName module name required
	 */
	private void combineRequire(String requiredModuleName) {

		// if css file, do not combine with js files
		// !TODO generate a combined css file
		if (requiredModuleName.endsWith(".css")) {
			if (!dependencies.contains(requiredModuleName)) {
				dependencies.add(requiredModuleName);
			}
			return;
		}

		// if specify exclude this module, just return
		if (excludePattern != null &&
				excludePattern.matcher(requiredModuleName).matches()) {
			if (!dependencies.contains(requiredModuleName)) {
				dependencies.add(requiredModuleName);
			}
			return;
		}

		Module requiredModule = packages.getModule(requiredModuleName);

		if (!requiredModule.isModuleExists()) {
			System.out.println("warning  module's file not found: " + requiredModuleName
					+ ": " + requiredModule.getFullpath());
			if (!dependencies.contains(requiredModuleName)) {
				dependencies.add(requiredModuleName);
			}
			return;
		}

		if (requiredModule.getAstRoot() == null) {
			System.out.println("!! format or syntax error in module: " + requiredModule.getFullpath());
			System.exit(1);
		}

		//x -> a,b,c
		//a -> b
		//when requiredModuleName=x and encounter b ,just return
		//reduce redundant parse and recursive
		if (modules.contains(requiredModule)) {
			return;
		}

		if (modulesVisited.contains(requiredModuleName)) {
			String error = "cyclic dependence: " +
					ArrayUtils.join(modulesVisited.toArray(new String[modulesVisited.size()]),
							",") + "," + requiredModuleName;
			//if silence ,just return
			System.out.println("error: " + error);
			System.exit(1);
			return;
		}

		//mark as start for cyclic detection
		modulesVisited.add(requiredModuleName);

		requiredModule.completeModuleName();

		String[] requires = requiredModule.getRequires();

		for (String require : requires) {
			combineRequire(require);
		}

		//remove mark for cyclic detection
		modulesVisited.remove(modulesVisited.size() - 1);

		modules.add(requiredModule);

		if (fixModuleName && !requiredModule.isWithModuleName()) {
			requiredModule.updateCodeToFile();
		}

	}


	public static void commandRunnerCLI(String[] args) throws Exception {

		Options options = new Options();
		options.addOption("encodings", true, "baseUrls 's encodings");
		options.addOption("baseUrls", true, "baseUrls");
		options.addOption("require", true, "require");
		options.addOption("excludeReg", true, "excludeReg");
		options.addOption("output", true, "output");
		options.addOption("v", "version", false, "version");
		options.addOption("outputEncoding", true, "outputEncoding");
		options.addOption("outputDependency", true, "outputDependency");
		options.addOption("fixModuleName", true, "fixModuleName");

		// create the command line parser
		CommandLineParser parser = new GnuParser();
		CommandLine line;

		try {
			// parse the command line arguments
			line = parser.parse(options, args);
		} catch (ParseException exp) {
			System.out.println("Unexpected exception:" + exp.getMessage());
			return;
		}

		if (line.hasOption("v")) {
			System.out.println("KISSY Module Compiler 1.3");
			return;
		}

		Main m = new Main();

		Packages packages = m.getPackages();

		String encodingStr = line.getOptionValue("encodings");
		if (encodingStr != null) {
			packages.setEncodings(encodingStr.split(","));
		}

		String baseUrlStr = line.getOptionValue("baseUrls");
		if (baseUrlStr != null) {
			packages.setBaseUrls(baseUrlStr.split(","));
		}

		String fixModuleName = line.getOptionValue("fixModuleName");
		if (fixModuleName != null) {
			m.setFixModuleName(true);
		}

		m.setRequire(line.getOptionValue("require"));

		String excludeReg = line.getOptionValue("excludeReg");
		if (excludeReg != null) {
			m.setExcludePattern(Pattern.compile(excludeReg));
		}

		m.setOutput(line.getOptionValue("output"));

		String outputEncoding = line.getOptionValue("outputEncoding");
		if (outputEncoding != null) {
			m.setOutputEncoding(outputEncoding);
		}

		m.setOutputDependency(line.getOptionValue("outputDependency"));

		m.run();

	}

	public static void main(String[] args) throws Exception {
		System.out.println("current path: " + new File(".").getAbsolutePath());
		System.out.println("current args: " + Arrays.toString(args));
		commandRunnerCLI(args);
	}
}
